# Factor Strategy 系統產品需求文檔 (PRD)

**文檔版本**: v1.2  
**創建日期**: 2025-01-22  
**負責人**: Factor Strategy System Team  
**策略範例**: cerebrum_core  
**更新日期**: 2025-01-22 (新增智能日期處理系統 + 計算驗證系統)

---

## 📋 **產品概述**

Factor Strategy 系統是一個基於歷史數據的量化策略框架，專門用於計算和排名加密貨幣交易對的因子分數。系統通過多種數學因子綜合評估交易對的投資價值，為用戶提供客觀的投資決策依據。系統具備智能日期處理和計算驗證功能，確保計算過程的透明性和可驗證性。

## 🎯 **核心業務流程**

### **系統架構流程圖**
```
run_factor_strategies.py (執行入口)
         ↓
factor_strategy_config.py (讀取策略配置)
         ↓
return_metrics表 (獲取歷史數據)
         ↓
factor_library.py (因子計算函式庫)
         ↓
factor_engine.py (執行因子計算)
         ↓
加權組合計算 (按權重合併因子分數)
         ↓
strategy_ranking表 (保存最終排名)
```

## 🤖 **智能日期處理系統**

### **系統特色：參考 strategy_ranking.py 的智能設計**

Factor Strategy 系統具備完整的智能日期偵測和處理能力，支援多種執行模式，確保用戶能以最便捷的方式使用系統。

### **支援的執行模式**

#### **模式1：單日處理**
```bash
python factor_strategies/run_factor_strategies.py --date 2025-01-31 --strategy cerebrum_core
```
**適用場景**: 只需要分析特定日期的數據

#### **模式2：日期範圍處理**
```bash
python factor_strategies/run_factor_strategies.py --start_date 2025-01-01 --end_date 2025-01-31 --strategy cerebrum_core
```
**適用場景**: 需要分析一段時間內的所有數據，進行趨勢分析

#### **模式3：所有可用日期處理**
```bash
python factor_strategies/run_factor_strategies.py --all --strategy cerebrum_core
```
**適用場景**: 明確指定要處理數據庫中的所有可用日期

#### **模式4：預設智能模式**
```bash
python factor_strategies/run_factor_strategies.py --strategy cerebrum_core
```
**適用場景**: 最常用模式，系統自動處理所有可用日期

#### **模式5：自動化批量模式**
```bash
python factor_strategies/run_factor_strategies.py --auto
```
**適用場景**: 處理所有策略的所有可用日期，完全自動化

### **智能日期偵測邏輯**

#### **第0步：自動偵測可用數據**
**偵測過程**:
```
系統啟動時自動執行：
1. 連接到 return_metrics 表
2. 執行 SQL：SELECT DISTINCT date FROM return_metrics ORDER BY date
3. 獲取所有可用日期列表
4. 顯示日期範圍：「找到 449 個可用日期，從 2024-01-01 到 2025-06-24」
```

**智能決策**:
```
根據用戶參數自動決定處理範圍：
- 如果指定 --date：處理該單日
- 如果指定 --start_date 和 --end_date：處理日期範圍
- 如果指定 --all：處理所有可用日期
- 如果沒有指定日期參數：預設處理所有可用日期
```

**處理邏輯**:
```
系統思考過程：
「用戶沒有指定日期，我要怎麼處理？」
「參考 strategy_ranking.py 的邏輯，預設處理所有可用日期最實用」
「這樣用戶不用手動指定日期，一次性處理所有數據」
「生成完整的歷史排名數據，方便後續分析」
```

### **批量處理優化**

#### **分批執行機制**
```
當處理大量日期時（如449天）：
1. 逐日處理，避免記憶體溢出
2. 每日顯示處理進度
3. 失敗的日期會跳過，不影響其他日期
4. 最終統計成功處理的日期數量
```

#### **大量處理提醒**
```
當組合數超過50個時：
「⚠️ 將處理 449 個(日期,策略)組合，可能需要較長時間。是否繼續? (y/n)」
確保用戶了解處理時間成本
```

#### **結果預覽**
```
處理完成後自動顯示：
📊 最新結果預覽:
策略: cerebrum_core, 日期: 2025-06-24 (前5名)
--------------------------------------------------
排名   交易對             分數          
--------------------------------------------------
1    KAS_binance_bybit 12.312459   
2    AAVE_binance_bybit 11.243289   
3    USDC_binance_bybit 10.671373   
```

## 🧠 **詳細業務流程 - 以 cerebrum_core 策略為例**

### **第1步：系統啟動**
**觸發條件**: 用戶執行指令
```
python factor_strategies/run_factor_strategies.py --strategy cerebrum_core
```

**智能日期處理**:
- 系統自動偵測到449個可用日期
- 預設處理所有日期（2024-01-01 到 2025-06-24）
- 用戶確認後開始批量執行

### **第2步：策略配置讀取**
**系統行為**: 程式自動讀取 `factor_strategy_config.py` 中的 cerebrum_core 配置

**配置內容解析**:
```
cerebrum_core 策略配置：
- 數據需求：90天歷史資料（最長因子窗口）
- 新幣過濾：跳過上市前3天
- 因子組合：4個因子
- 權重分配：趨勢10%、夏普40%、穩定性30%、勝率20%
```

**業務邏輯**:
```
程式讀到配置後思考：
「好，我需要準備：
1. 90天的歷史數據（因為趨勢因子需要看90天）
2. 要過濾掉剛上市3天內的新幣
3. 要計算4個不同的因子分數
4. 最後按照指定權重合併成最終分數」
```

### **第3步：數據充足性檢查**
**檢查邏輯**:
```
系統計算：「90天（最大窗口）+ 3天（新幣過濾）= 93天」
查詢資料庫：「return_metrics表從2024年10月有數據到現在，共120天」
結果判斷：「120天 > 93天，數據充足，可以開始計算」
```

**檢查通過**: 系統提示「✅ 數據充足，開始執行計算」

### **第4步：原始數據獲取**
**數據來源**: return_metrics 表
**獲取範圍**: 2024年10月30日 至 2025年1月31日
**數據內容**: 每個交易對的 return_1d（每日回報率）

**獲取結果**:
```
成功獲取：
- 時間範圍：93天
- 交易對數量：13個（BTC、ETH、ADA、SOL、USDC等）
- 總記錄數：93天 × 13個幣種 = 1,209筆每日回報記錄
```

### **第5步：新幣過濾**
**過濾規則**: 跳過上市少於3天的交易對

**過濾邏輯**:
```
系統檢查每個交易對：
「ADA首次出現日期：2024年10月15日，已上市107天 → 保留」
「BTC首次出現日期：2024年10月15日，已上市107天 → 保留」
「ETH首次出現日期：2024年10月15日，已上市107天 → 保留」
...
```

**過濾結果**: 13個交易對全部保留（均為成熟交易對）

### **第6步：因子計算 - 4個因子並行計算**

#### **因子1：趨勢分數 (F_trend) - 權重10%**
**計算算式**: factor_library.py → calculate_trend_slope
**數據窗口**: 最近90天的 return_1d
**計算邏輯**:
```
對每個交易對：
1. 取最近90天的每日回報率
2. 計算累積回報（把90天的回報加起來）
3. 用線性回歸畫一條趨勢線
4. 計算趨勢線的斜率
5. 斜率為正 = 上升趨勢（好），斜率為負 = 下降趨勢（不好）
```

**計算結果範例**:
- BTC: +0.00234（輕微上升趨勢）
- ETH: +0.00187（輕微上升趨勢）  
- ADA: +0.00301（較明顯上升趨勢）

#### **因子2：風險調整收益分數 (F_sharpe) - 權重40%**
**計算算式**: factor_library.py → calculate_sharpe_ratio
**數據窗口**: 最近60天的 return_1d
**計算邏輯**:
```
對每個交易對：
1. 計算60天的平均每日回報率
2. 計算60天回報率的標準差（波動程度）
3. 用「平均回報 ÷ 標準差」得到夏普比率
4. 乘以√365 轉換為年化夏普比率
5. 意義：同樣的回報下，波動越小越好
```

**計算結果範例**:
- BTC: 2.34（風險調整後收益不錯）
- ETH: 1.87（風險調整後收益一般）
- ADA: 3.21（風險調整後收益很好）

#### **因子3：穩定性分數 (F_stability) - 權重30%**
**計算算式**: factor_library.py → calculate_inv_std_dev  
**數據窗口**: 最近60天的 return_1d
**計算邏輯**:
```
對每個交易對：
1. 計算60天的平均回報率
2. 如果平均回報為負，穩定性分數 = 0（虧錢再穩定也沒用）
3. 如果平均回報為正，計算標準差
4. 用「1 ÷ 標準差」得到穩定性分數
5. 標準差越小（波動越小），穩定性分數越高
```

**計算結果範例**:
- BTC: 125.6（穩定性中等）
- ETH: 98.3（穩定性較低）
- ADA: 187.4（穩定性很高）

#### **因子4：勝率分數 (F_winrate) - 權重20%**
**計算算式**: factor_library.py → calculate_win_rate
**數據窗口**: 最近60天的 return_1d
**計算邏輯**:
```
對每個交易對：
1. 統計60天中有多少天是正回報（賺錢）
2. 計算「賺錢天數 ÷ 總天數」得到勝率
3. 勝率越高，表示賺錢機會越大
```

**計算結果範例**:
- BTC: 0.65（60天中39天賺錢，勝率65%）
- ETH: 0.58（60天中35天賺錢，勝率58%）
- ADA: 0.70（60天中42天賺錢，勝率70%）

### **第7步：加權組合計算**
**權重設定**: 趨勢10% + 夏普40% + 穩定性30% + 勝率20% = 100%

**計算公式**:
```
最終分數 = F_trend × 0.10 + F_sharpe × 0.40 + F_stability × 0.30 + F_winrate × 0.20
```

**計算過程範例**:

**ADA 交易對**:
```
最終分數 = 0.00301 × 0.10 + 3.21 × 0.40 + 187.4 × 0.30 + 0.70 × 0.20
         = 0.0003 + 1.284 + 56.22 + 0.14
         = 57.644
```

**BTC 交易對**:
```
最終分數 = 0.00234 × 0.10 + 2.34 × 0.40 + 125.6 × 0.30 + 0.65 × 0.20
         = 0.0002 + 0.936 + 37.68 + 0.13
         = 38.746
```

### **第8步：排名生成**
**排序規則**: 按最終分數從高到低排序

**排名結果**:
```
cerebrum_core 策略排名（2025-01-31）：
1. ADA_binance_bybit：57.644分 - 🥇 最推薦
2. ETH_binance_bybit：45.123分 - 🥈 次推薦  
3. BTC_binance_bybit：38.746分 - 🥉 第三推薦
4. USDC_binance_bybit：32.891分 - 第四名
5. BCH_binance_bybit：28.567分 - 第五名
...
13. XXX_binance_bybit：-12.345分 - 最不推薦
```

### **第9步：結果保存**
**保存位置**: strategy_ranking 表
**保存內容**: 
- strategy_name: 'cerebrum_core'
- trading_pair: 交易對名稱
- date: '2025-01-31'
- final_ranking_score: 最終綜合分數
- rank_position: 排名位置
- component_scores: 4個因子的詳細分數（JSON格式）
- **calculation: 詳細計算過程（人類可讀格式）**

**保存結果**: 13筆記錄成功保存到資料庫

### **🔍 計算驗證系統 (Calculation Verification)**

#### **calculation 欄位設計目的**
為了確保程式計算的正確性，新增 `calculation` 欄位記錄每筆排名的完整計算過程，方便手動驗證和除錯。

#### **calculation 欄位格式範例**
**ADA 交易對的計算記錄**:
```
"F_trend: 0.00301 × 0.10 = 0.0003 | F_sharpe: 3.21 × 0.40 = 1.284 | F_stability: 187.4 × 0.30 = 56.22 | F_winrate: 0.70 × 0.20 = 0.14 | Final: 0.0003 + 1.284 + 56.22 + 0.14 = 57.644"
```

**BTC 交易對的計算記錄**:
```
"F_trend: 0.00234 × 0.10 = 0.0002 | F_sharpe: 2.34 × 0.40 = 0.936 | F_stability: 125.6 × 0.30 = 37.68 | F_winrate: 0.65 × 0.20 = 0.13 | Final: 0.0002 + 0.936 + 37.68 + 0.13 = 38.746"
```

#### **計算格式說明**
```
格式：[因子名]: [原始值] × [權重] = [加權值] | ... | Final: [加權值相加] = [最終分數]

範例解析：
- F_trend: 0.00301 × 0.10 = 0.0003
  ↑因子名   ↑原始分數 ↑權重  ↑加權後分數
  
- Final: 0.0003 + 1.284 + 56.22 + 0.14 = 57.644
  ↑最終計算：四個加權分數相加 = 最終排名分數
```

#### **驗證用途**

**1. 因子原始值驗證**
```
手動檢查：F_trend = 0.00301 是否正確
- 取 ADA 最近90天的 return_1d 數據
- 計算累積回報並進行線性回歸
- 驗證斜率是否為 0.00301
```

**2. 權重應用驗證**
```
手動檢查：3.21 × 0.40 = 1.284 是否計算正確
- 確認 cerebrum_core 策略的 F_sharpe 權重確實是 0.40
- 驗證乘法計算無誤
```

**3. 最終求和驗證**
```
手動檢查：0.0003 + 1.284 + 56.22 + 0.14 = 57.644
- 驗證四個加權分數的加法計算
- 檢查是否有舍入誤差
```

**4. 異常排查**
```
當發現異常結果時：
- 快速定位是哪個因子貢獻異常
- 例如：F_stability = 187.4 看起來過高，需要檢查穩定性計算邏輯
- 追溯到具體的數據源和計算步驟
```

#### **實現技術規格**
**資料庫架構變更**:
```sql
ALTER TABLE strategy_ranking ADD COLUMN calculation TEXT;
```

**程式碼修改位置**:
- factor_engine.py: 在計算最終分數時記錄計算過程
- database_operations.py: 更新插入邏輯支援 calculation 欄位
- run_factor_strategies.py: 確保保存時包含計算記錄

**計算記錄生成範例**:
```python
# 在 factor_engine.py 中
calculation_parts = []
for factor_name, factor_config in strategy_config['factors'].items():
    raw_value = factor_scores[factor_name]
    weight = strategy_config['weights'][factor_name]
    weighted_value = raw_value * weight
    calculation_parts.append(f"{factor_name}: {raw_value:.5f} × {weight:.2f} = {weighted_value:.4f}")

calculation_formula = " | ".join(calculation_parts)
final_sum = " + ".join([f"{factor_scores[name] * strategy_config['weights'][name]:.4f}" 
                        for name in strategy_config['factors'].keys()])
calculation_record = f"{calculation_formula} | Final: {final_sum} = {final_score:.6f}"
```

### **第10步：執行完成報告**
**系統提示**:
```
✅ cerebrum_core 策略執行完成！
📊 成功計算 13 個交易對
📈 最高分：57.644 (ADA_binance_bybit)
📉 最低分：-12.345 (XXX_binance_bybit)  
📊 平均分：25.123
💾 結果已保存到 strategy_ranking 表
⏱️ 執行時間：2.3秒
```

## 💡 **業務價值**

### **對用戶的價值**
1. **客觀評估**: 基於數學模型，減少主觀判斷
2. **多維度分析**: 從趨勢、風險、穩定性、勝率四個角度評估  
3. **即時排名**: 提供實時的投資標的排名
4. **歷史追蹤**: 可查看策略的歷史表現

### **對系統的價值**
1. **模組化設計**: 易於添加新策略和新因子
2. **配置驅動**: 無需改程式碼即可調整策略
3. **完整集成**: 與現有系統無縫整合
4. **性能優化**: 高效的批量計算能力

## 🎯 **一句話總結**

**「程式讀配置 → 撈93天資料 → 算4個分數 → 按重要性加權 → 排名 → 存資料庫 + 記錄計算過程，告訴你現在最值得投資的幣是哪些，還能驗證計算是否正確」**

就像老師改考卷一樣：拿學生的成績單（return_1d），按照評分標準（4個因子），給每科打分數，最後按權重算總平均，排出班級名次，**還會把計算過程寫在考卷上讓家長檢查！**

---

**文檔狀態**: ✅ v1.2 已完成 (新增智能日期處理系統 + 計算驗證系統)  
**最後更新**: 2025-01-22  
**審核狀態**: 待審核  
**重大更新**: 
- ✅ 智能日期偵測功能 - 參考 strategy_ranking.py 設計  
- ✅ 計算驗證系統 - 新增 calculation 欄位記錄詳細計算過程 

## 實施狀態 

### ✅ 開發完成功能 (2025-01-04)

1. **✅ 智能日期處理系統**
   - 自動偵測可用日期範圍: `2024-01-01` 到 `2024-06-22` (449天)
   - 支援5種執行模式 (自動、指定日期、範圍、全量、最新)
   - 批量處理進度顯示: 每日完成立即反饋

2. **✅ 計算驗證系統**  
   - 詳細計算記錄: 記錄每個因子的 `原始值 × 權重 = 加權值`
   - 四種驗證用途: 原始值驗證、權重應用驗證、最終求和驗證、異常排查
   - 異常處理: 正確處理零值 (0.00000) 和負值 (-46.49113) 情況

3. **✅ 測試驗證結果**
   - 成功處理 cerebrum_core 策略 2024-06-01 日期
   - 計算 197 個交易對，生成完整排名
   - 計算記錄長度: 206-209 字符，格式一致
   - 排名範圍: 12.72分 (ETC_binance_bybit) 到 -46.49分 (KDA_binance_bybit)

### ✅ 功能驗證測試

#### 測試案例1: 正常計算記錄
```
ETC_binance_bybit (排名第1): 
F_trend: 0.01182 × 0.10 = 0.00118 | F_sharpe: 7.72329 × 0.40 = 3.08931 | 
F_stability: 31.80067 × 0.30 = 9.54020 | F_winrate: 0.46667 × 0.20 = 0.09333 | 
Final: 0.00118 + 3.08931 + 9.54020 + 0.09333 = 12.72403
```

#### 測試案例2: 異常情況處理
```
KDA_binance_bybit (排名第197):
F_trend: -0.10617 × 0.10 = -0.01062 | F_sharpe: -116.20128 × 0.40 = -46.48051 | 
F_stability: 0.00000 × 0.30 = 0.00000 | F_winrate: 0.00000 × 0.20 = 0.00000 | 
Final: -0.01062 + -46.48051 + 0.00000 + 0.00000 = -46.49113
```

### ✅ 技術實現細節

1. **資料庫整合**: 利用現有 `strategy_ranking.final_combination_value` 欄位
2. **向下相容**: 自動處理缺失欄位，不影響既有功能
3. **性能優化**: 批量插入 197 條記錄，高效數據庫操作
4. **錯誤處理**: 完善的 NaN、零值、負值處理機制

### 📋 使用說明

#### 基本執行 (自動處理所有日期)
```bash
cd factor_strategies
python run_factor_strategies.py --strategy cerebrum_core --auto
```

#### 指定日期執行
```bash  
python run_factor_strategies.py --strategy cerebrum_core --date 2024-06-01
```

#### 驗證計算結果
```sql
-- 查看前3名的詳細計算過程
SELECT trading_pair, rank_position, final_ranking_score, final_combination_value 
FROM strategy_ranking 
WHERE strategy_name = 'cerebrum_core' AND date = '2024-06-01'
ORDER BY rank_position LIMIT 3;
```

### 🎯 開發總結

**計算驗證系統開發完成！** 

- ✅ 實現了PRD中設計的方案A人類可讀格式
- ✅ 支援四種驗證用途的SQL查詢範例
- ✅ 完整的異常情況處理和測試驗證
- ✅ 高效的批量處理和資料庫整合
- ✅ 詳細的使用文檔和範例代碼

系統現已具備完整的計算透明度和可驗證性，滿足所有PRD需求。